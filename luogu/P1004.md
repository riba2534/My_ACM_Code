## 题目描述

> 设有$N \times N​$的方格图$(N \le 9)​$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字$0​$。如下图所示（见样例）:
>
> ```cpp
> A
>  0  0  0  0  0  0  0  0
>  0  0 13  0  0  6  0  0
>  0  0  0  0  7  0  0  0
>  0  0  0 14  0  0  0  0
>  0 21  0  0  0  4  0  0
>  0  0 15  0  0  0  0  0
>  0 14  0  0  0  0  0  0
>  0  0  0  0  0  0  0  0
>                          B
> ```
>
> 某人从图的左上角的$A​$点出发，可以向下行走，也可以向右走，直到到达右下角的$B​$点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字$0​$）。
> 此人从$A​$点到$B​$点共走两次，试找出$2​$条这样的路径，使得取得的数之和为最大。

## 输入格式：

> 输入的第一行为一个整数$N​$（表示$N \times N​$的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的$0​$表示输入结束。

## 输出格式：

> 只需输出一个整数，表示$2$条路径上取得的最大的和。

### 输入样例

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出样例

```
67
```

## 思路

四维 dp ，和传纸条的问题类似。

定义 $dp[i][j][k][l]​$ 为第一个人走到 $(i.j)​$ 第二个人走到 $(k,l)​$ 的最大价值.

所以在以下四个转移中取最大值即可。

```
dp[i - 1][j][k - 1][l]
dp[i][j - 1][k - 1][l]
dp[i - 1][j][k][l - 1]
dp[i][j - 1][k][l - 1]
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 12;
int dp[N][N][N][N];
int e[N][N];

int main()
{
    //freopen("in.txt", "r", stdin);
    int n, u, v, w;
    scanf("%d", &n);
    while (scanf("%d%d%d", &u, &v, &w) && (u || v || w))
        e[u][v] = w;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            for (int k = 1; k <= n; k++)
                for (int l = 1; l <= n; l++)
                {
                    dp[i][j][k][l] = max(dp[i - 1][j][k - 1][l],
                                         max(dp[i][j - 1][k - 1][l],
                                             max(dp[i - 1][j][k][l - 1],
                                                 dp[i][j - 1][k][l - 1]))) +
                                     e[i][j] + e[k][l];
                    if (i == k && j == l)
                        dp[i][j][k][l] -= e[i][j];
                }
    printf("%d\n", dp[n][n][n][n]);
    return 0;
}
```

